# Enhanced Batch Processing Implementation

## Comprehensive Batch Management with Fallback API Polling

This implementation provides robust batch processing with WebSocket real-time updates and REST API fallback for error handling and status polling.

## Frontend Implementation

### Enhanced WebSocket Context with Batch Management

```typescript
// context/EnhancedWebSocketContext.tsx
"use client";

import React, { createContext, useContext, useState, useEffect, useRef, useCallback } from 'react';
import { toast } from 'react-hot-toast';
import { useAuth } from './AuthContext';

interface BatchState {
  batch_id: string;
  file_id: string;
  page_number: number;
  status: 'pending' | 'processing' | 'completed' | 'failed' | 'cancelled';
  extraction_types: ExtractionType[];
  progress: {
    completed_items: number;
    total_items: number;
    percentage: number;
    current_stage?: string;
  };
  items: Record<string, BatchItem>;
  created_at: string;
  updated_at: string;
  error?: BatchError;
}

interface BatchItem {
  annotation_id: string;
  extraction_type: ExtractionType;
  status: 'pending' | 'processing' | 'completed' | 'failed';
  result?: any;
  error?: {
    code: string;
    message: string;
    timestamp: string;
  };
  processing_time?: number;
}

interface BatchError {
  code: string;
  message: string;
  recoverable: boolean;
  retry_after?: number;
}

interface EnhancedWebSocketContextType {
  // Connection state
  isConnected: boolean;
  connectionStatus: 'connecting' | 'connected' | 'disconnected' | 'error';
  
  // Batch management
  activeBatches: Record<string, BatchState>;
  createBatch: (fileId: string, pageNumber: number, annotations: Annotation[]) => Promise<string>;
  retryBatch: (batchId: string, failedOnly?: boolean) => Promise<void>;
  cancelBatch: (batchId: string) => Promise<void>;
  getBatchStatus: (batchId: string) => Promise<BatchState>;
  
  // Polling management
  startPolling: (batchIds: string[]) => void;
  stopPolling: (batchId?: string) => void;
  
  // Multiple batch operations
  createMultipleBatches: (requests: Array<{fileId: string, pageNumber: number, annotations: Annotation[]}>) => Promise<string[]>;
  getActiveBatches: () => Promise<BatchState[]>;
  
  // Subscription management
  subscribeToBatch: (batchId: string, callback: (batch: BatchState) => void) => () => void;
}

export const EnhancedWebSocketContext = createContext<EnhancedWebSocketContextType | null>(null);

export const EnhancedWebSocketProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const { user } = useAuth();
  const [isConnected, setIsConnected] = useState(false);
  const [connectionStatus, setConnectionStatus] = useState<'connecting' | 'connected' | 'disconnected' | 'error'>('disconnected');
  const [activeBatches, setActiveBatches] = useState<Record<string, BatchState>>({});
  
  const wsRef = useRef<WebSocket | null>(null);
  const reconnectTimeoutRef = useRef<NodeJS.Timeout>();
  const pollingIntervalsRef = useRef<Record<string, NodeJS.Timeout>>({});
  const batchSubscribersRef = useRef<Record<string, Set<Function>>>({});
  const clientId = useRef(`client_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`);

  // WebSocket connection management
  const connect = useCallback(() => {
    if (!user || wsRef.current?.readyState === WebSocket.OPEN) return;

    setConnectionStatus('connecting');
    
    const wsUrl = `${process.env.NEXT_PUBLIC_WS_URL}?client_id=${clientId.current}&token=${user.token}`;
    wsRef.current = new WebSocket(wsUrl);

    wsRef.current.onopen = () => {
      setIsConnected(true);
      setConnectionStatus('connected');
      toast.success('Real-time connection established');
      
      // Request status for all active batches
      Object.keys(activeBatches).forEach(batchId => {
        requestBatchStatus(batchId);
      });
    };

    wsRef.current.onmessage = handleWebSocketMessage;
    
    wsRef.current.onclose = () => {
      setIsConnected(false);
      setConnectionStatus('disconnected');
      
      // Start polling for active batches as fallback
      const activeBatchIds = Object.keys(activeBatches).filter(
        id => ['pending', 'processing'].includes(activeBatches[id].status)
      );
      if (activeBatchIds.length > 0) {
        startPolling(activeBatchIds);
      }
      
      // Attempt reconnection
      reconnectTimeoutRef.current = setTimeout(connect, 3000);
    };

    wsRef.current.onerror = () => {
      setConnectionStatus('error');
    };
  }, [user, activeBatches]);

  // Handle incoming WebSocket messages
  const handleWebSocketMessage = useCallback((event: MessageEvent) => {
    try {
      const message = JSON.parse(event.data);
      
      switch (message.type) {
        case 'batch_created':
          handleBatchCreated(message);
          break;
        case 'batch_progress':
          handleBatchProgress(message);
          break;
        case 'batch_item_completed':
          handleBatchItemCompleted(message);
          break;
        case 'batch_completed':
          handleBatchCompleted(message);
          break;
        case 'batch_error':
          handleBatchError(message);
          break;
        default:
          console.log('Unknown message type:', message.type);
      }
    } catch (error) {
      console.error('Failed to parse WebSocket message:', error);
    }
  }, []);

  // Message handlers
  const handleBatchCreated = useCallback((message: any) => {
    const batchState: BatchState = {
      batch_id: message.batch_id,
      file_id: message.file_id,
      page_number: message.page_number,
      status: 'pending',
      extraction_types: message.extraction_types,
      progress: {
        completed_items: 0,
        total_items: message.total_annotations,
        percentage: 0
      },
      items: {},
      created_at: message.timestamp,
      updated_at: message.timestamp
    };

    setActiveBatches(prev => ({
      ...prev,
      [message.batch_id]: batchState
    }));

    notifyBatchSubscribers(message.batch_id, batchState);
  }, []);

  const handleBatchProgress = useCallback((message: any) => {
    setActiveBatches(prev => {
      const batch = prev[message.batch_id];
      if (!batch) return prev;

      const updatedBatch = {
        ...batch,
        status: 'processing' as const,
        progress: message.progress,
        updated_at: message.timestamp
      };

      notifyBatchSubscribers(message.batch_id, updatedBatch);

      return {
        ...prev,
        [message.batch_id]: updatedBatch
      };
    });
  }, []);

  const handleBatchItemCompleted = useCallback((message: any) => {
    setActiveBatches(prev => {
      const batch = prev[message.batch_id];
      if (!batch) return prev;

      const updatedItems = {
        ...batch.items,
        [message.annotation_id]: {
          annotation_id: message.annotation_id,
          extraction_type: message.extraction_type,
          status: message.success ? 'completed' as const : 'failed' as const,
          result: message.result,
          error: message.error,
          processing_time: message.processing_time
        }
      };

      const updatedBatch = {
        ...batch,
        items: updatedItems,
        updated_at: message.timestamp
      };

      notifyBatchSubscribers(message.batch_id, updatedBatch);

      return {
        ...prev,
        [message.batch_id]: updatedBatch
      };
    });
  }, []);

  const handleBatchCompleted = useCallback((message: any) => {
    setActiveBatches(prev => {
      const batch = prev[message.batch_id];
      if (!batch) return prev;

      const updatedBatch = {
        ...batch,
        status: message.status,
        progress: {
          ...batch.progress,
          percentage: 100,
          completed_items: message.summary.completed_items
        },
        updated_at: message.timestamp
      };

      // Update individual items with results
      message.results.forEach((result: any) => {
        updatedBatch.items[result.annotation_id] = {
          annotation_id: result.annotation_id,
          extraction_type: result.extraction_type,
          status: result.success ? 'completed' : 'failed',
          result: result.result,
          error: result.error
        };
      });

      notifyBatchSubscribers(message.batch_id, updatedBatch);

      // Stop polling for this batch
      stopPolling(message.batch_id);

      return {
        ...prev,
        [message.batch_id]: updatedBatch
      };
    });
  }, []);

  const handleBatchError = useCallback((message: any) => {
    setActiveBatches(prev => {
      const batch = prev[message.batch_id];
      if (!batch) return prev;

      const updatedBatch = {
        ...batch,
        status: 'failed' as const,
        error: message.error,
        updated_at: message.timestamp
      };

      notifyBatchSubscribers(message.batch_id, updatedBatch);

      // If error is recoverable, offer retry option
      if (message.error.recoverable) {
        toast.error(
          `Batch processing failed: ${message.error.message}`, 
          {
            duration: 0,
            action: {
              label: 'Retry',
              onClick: () => retryBatch(message.batch_id)
            }
          }
        );
      } else {
        toast.error(`Batch processing failed: ${message.error.message}`);
      }

      return {
        ...prev,
        [message.batch_id]: updatedBatch
      };
    });
  }, []);

  // Batch management functions
  const createBatch = useCallback(async (
    fileId: string, 
    pageNumber: number, 
    annotations: Annotation[]
  ): Promise<string> => {
    try {
      const response = await fetch('/api/batch/create', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${user?.token}`
        },
        body: JSON.stringify({
          file_id: fileId,
          page_number: pageNumber,
          annotations: annotations.map(a => ({
            id: a.id,
            type: a.type,
            bbox: a.bbox,
            extraction_types: ['text', 'table', 'diagram'] // Configure as needed
          })),
          options: {
            client_id: clientId.current,
            priority: 'normal'
          }
        })
      });

      if (!response.ok) {
        throw new Error(`Failed to create batch: ${response.statusText}`);
      }

      const data = await response.json();
      
      // If WebSocket is not connected, start polling
      if (!isConnected) {
        startPolling([data.batch_id]);
      }

      return data.batch_id;
    } catch (error) {
      console.error('Error creating batch:', error);
      throw error;
    }
  }, [user, isConnected]);

  const getBatchStatus = useCallback(async (batchId: string): Promise<BatchState> => {
    try {
      const response = await fetch(`/api/batch/${batchId}/status`, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${user?.token}`
        }
      });

      if (!response.ok) {
        throw new Error(`Failed to get batch status: ${response.statusText}`);
      }

      const data = await response.json();
      
      // Update local state
      setActiveBatches(prev => ({
        ...prev,
        [batchId]: data
      }));

      notifyBatchSubscribers(batchId, data);

      return data;
    } catch (error) {
      console.error('Error getting batch status:', error);
      throw error;
    }
  }, [user]);

  const retryBatch = useCallback(async (batchId: string, failedOnly: boolean = true): Promise<void> => {
    try {
      const response = await fetch(`/api/batch/${batchId}/retry`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${user?.token}`
        },
        body: JSON.stringify({
          retry_failed_only: failedOnly
        })
      });

      if (!response.ok) {
        throw new Error(`Failed to retry batch: ${response.statusText}`);
      }

      // Start polling if WebSocket is not connected
      if (!isConnected) {
        startPolling([batchId]);
      }

      toast.success('Batch retry initiated');
    } catch (error) {
      console.error('Error retrying batch:', error);
      toast.error('Failed to retry batch');
      throw error;
    }
  }, [user, isConnected]);

  const cancelBatch = useCallback(async (batchId: string): Promise<void> => {
    try {
      const response = await fetch(`/api/batch/${batchId}/cancel`, {
        method: 'DELETE',
        headers: {
          'Authorization': `Bearer ${user?.token}`
        }
      });

      if (!response.ok) {
        throw new Error(`Failed to cancel batch: ${response.statusText}`);
      }

      // Update local state
      setActiveBatches(prev => {
        const batch = prev[batchId];
        if (!batch) return prev;

        const updatedBatch = {
          ...batch,
          status: 'cancelled' as const,
          updated_at: new Date().toISOString()
        };

        notifyBatchSubscribers(batchId, updatedBatch);

        return {
          ...prev,
          [batchId]: updatedBatch
        };
      });

      stopPolling(batchId);
      toast.success('Batch cancelled successfully');
    } catch (error) {
      console.error('Error cancelling batch:', error);
      toast.error('Failed to cancel batch');
      throw error;
    }
  }, [user]);

  // Polling management
  const startPolling = useCallback((batchIds: string[]) => {
    batchIds.forEach(batchId => {
      if (pollingIntervalsRef.current[batchId]) return; // Already polling

      const pollBatch = async () => {
        try {
          const batchState = await getBatchStatus(batchId);
          
          // Stop polling if batch is completed
          if (['completed', 'failed', 'cancelled'].includes(batchState.status)) {
            stopPolling(batchId);
          }
        } catch (error) {
          console.error(`Error polling batch ${batchId}:`, error);
          // Continue polling on error, but with exponential backoff
        }
      };

      // Initial poll
      pollBatch();
      
      // Set up interval polling
      pollingIntervalsRef.current[batchId] = setInterval(pollBatch, 2000); // Poll every 2 seconds
    });
  }, [getBatchStatus]);

  const stopPolling = useCallback((batchId?: string) => {
    if (batchId) {
      if (pollingIntervalsRef.current[batchId]) {
        clearInterval(pollingIntervalsRef.current[batchId]);
        delete pollingIntervalsRef.current[batchId];
      }
    } else {
      // Stop all polling
      Object.values(pollingIntervalsRef.current).forEach(interval => {
        clearInterval(interval);
      });
      pollingIntervalsRef.current = {};
    }
  }, []);

  // Multiple batch operations
  const createMultipleBatches = useCallback(async (
    requests: Array<{fileId: string, pageNumber: number, annotations: Annotation[]}>
  ): Promise<string[]> => {
    const batchIds = await Promise.all(
      requests.map(req => createBatch(req.fileId, req.pageNumber, req.annotations))
    );
    
    return batchIds;
  }, [createBatch]);

  const getActiveBatches = useCallback(async (): Promise<BatchState[]> => {
    try {
      const response = await fetch('/api/batches/active', {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${user?.token}`
        }
      });

      if (!response.ok) {
        throw new Error(`Failed to get active batches: ${response.statusText}`);
      }

      const data = await response.json();
      return data.batches;
    } catch (error) {
      console.error('Error getting active batches:', error);
      throw error;
    }
  }, [user]);

  // Subscription management
  const subscribeToBatch = useCallback((
    batchId: string, 
    callback: (batch: BatchState) => void
  ) => {
    if (!batchSubscribersRef.current[batchId]) {
      batchSubscribersRef.current[batchId] = new Set();
    }
    
    batchSubscribersRef.current[batchId].add(callback);

    // Return unsubscribe function
    return () => {
      batchSubscribersRef.current[batchId]?.delete(callback);
      if (batchSubscribersRef.current[batchId]?.size === 0) {
        delete batchSubscribersRef.current[batchId];
      }
    };
  }, []);

  const notifyBatchSubscribers = useCallback((batchId: string, batch: BatchState) => {
    batchSubscribersRef.current[batchId]?.forEach(callback => {
      try {
        callback(batch);
      } catch (error) {
        console.error('Error in batch subscriber callback:', error);
      }
    });
  }, []);

  const requestBatchStatus = useCallback((batchId: string) => {
    if (wsRef.current?.readyState === WebSocket.OPEN) {
      wsRef.current.send(JSON.stringify({
        type: 'get_batch_status',
        batch_id: batchId,
        client_id: clientId.current,
        timestamp: new Date().toISOString()
      }));
    }
  }, []);

  // Auto-connect and cleanup
  useEffect(() => {
    if (user) {
      connect();
    }

    return () => {
      stopPolling();
      if (reconnectTimeoutRef.current) {
        clearTimeout(reconnectTimeoutRef.current);
      }
      if (wsRef.current) {
        wsRef.current.close();
      }
    };
  }, [user, connect]);

  const contextValue: EnhancedWebSocketContextType = {
    isConnected,
    connectionStatus,
    activeBatches,
    createBatch,
    retryBatch,
    cancelBatch,
    getBatchStatus,
    startPolling,
    stopPolling,
    createMultipleBatches,
    getActiveBatches,
    subscribeToBatch
  };

  return (
    <EnhancedWebSocketContext.Provider value={contextValue}>
      {children}
    </EnhancedWebSocketContext.Provider>
  );
};

export const useEnhancedWebSocket = () => {
  const context = useContext(EnhancedWebSocketContext);
  if (!context) {
    throw new Error('useEnhancedWebSocket must be used within EnhancedWebSocketProvider');
  }
  return context;
};
```

### Batch Processing Hook

```typescript
// hooks/useBatchProcessing.ts
import { useCallback, useEffect, useState } from 'react';
import { useEnhancedWebSocket } from '@/context/EnhancedWebSocketContext';

interface BatchProcessingHookProps {
  fileId: string;
  pageNumber: number;
}

export const useBatchProcessing = ({ fileId, pageNumber }: BatchProcessingHookProps) => {
  const {
    createBatch,
    retryBatch,
    cancelBatch,
    getBatchStatus,
    subscribeToBatch,
    activeBatches,
    isConnected,
    connectionStatus
  } = useEnhancedWebSocket();

  const [currentBatchId, setCurrentBatchId] = useState<string | null>(null);
  const [processingState, setProcessingState] = useState<{
    isProcessing: boolean;
    progress: number;
    currentStage: string;
    error?: string;
  }>({
    isProcessing: false,
    progress: 0,
    currentStage: ''
  });

  // Process annotations with comprehensive error handling
  const processAnnotations = useCallback(async (annotations: Annotation[]) => {
    if (annotations.length === 0) {
      throw new Error('No annotations to process');
    }

    try {
      // Set optimistic processing state
      setProcessingState({
        isProcessing: true,
        progress: 0,
        currentStage: 'Creating batch...'
      });

      const batchId = await createBatch(fileId, pageNumber, annotations);
      setCurrentBatchId(batchId);

      return batchId;
    } catch (error) {
      setProcessingState({
        isProcessing: false,
        progress: 0,
        currentStage: '',
        error: error instanceof Error ? error.message : 'Unknown error'
      });
      throw error;
    }
  }, [createBatch, fileId, pageNumber]);

  // Retry failed batch
  const retryProcessing = useCallback(async (failedOnly: boolean = true) => {
    if (!currentBatchId) return;

    try {
      setProcessingState(prev => ({
        ...prev,
        isProcessing: true,
        currentStage: 'Retrying batch...',
        error: undefined
      }));

      await retryBatch(currentBatchId, failedOnly);
    } catch (error) {
      setProcessingState(prev => ({
        ...prev,
        isProcessing: false,
        error: error instanceof Error ? error.message : 'Retry failed'
      }));
      throw error;
    }
  }, [currentBatchId, retryBatch]);

  // Cancel current batch
  const cancelProcessing = useCallback(async () => {
    if (!currentBatchId) return;

    try {
      await cancelBatch(currentBatchId);
      setCurrentBatchId(null);
      setProcessingState({
        isProcessing: false,
        progress: 0,
        currentStage: 'Cancelled'
      });
    } catch (error) {
      console.error('Error cancelling batch:', error);
    }
  }, [currentBatchId, cancelBatch]);

  // Get current batch state
  const getCurrentBatch = useCallback(() => {
    return currentBatchId ? activeBatches[currentBatchId] : null;
  }, [currentBatchId, activeBatches]);

  // Subscribe to batch updates
  useEffect(() => {
    if (!currentBatchId) return;

    const unsubscribe = subscribeToBatch(currentBatchId, (batch) => {
      setProcessingState({
        isProcessing: ['pending', 'processing'].includes(batch.status),
        progress: batch.progress.percentage,
        currentStage: batch.progress.current_stage || batch.status,
        error: batch.error?.message
      });

      // Clear current batch if completed
      if (['completed', 'failed', 'cancelled'].includes(batch.status)) {
        // Keep batch ID for result access, but mark as not processing
        setTimeout(() => {
          if (batch.status !== 'failed') {
            setCurrentBatchId(null);
          }
        }, 5000); // Clear after 5 seconds for successful completions
      }
    });

    return unsubscribe;
  }, [currentBatchId, subscribeToBatch]);

  // Health check for connection status
  const connectionHealth = {
    isConnected,
    status: connectionStatus,
    usingFallback: !isConnected && processingState.isProcessing
  };

  return {
    processAnnotations,
    retryProcessing,
    cancelProcessing,
    getCurrentBatch,
    processingState,
    connectionHealth,
    currentBatchId
  };
};
```

### Enhanced UI Components

```typescript
// components/EnhancedAnnotationControls.tsx
"use client";
import React, { useCallback, useMemo } from "react";
import { useBatchProcessing } from "@/hooks/useBatchProcessing";
import { useEnhancedWebSocket } from "@/context/EnhancedWebSocketContext";
import { AlertCircle, CheckCircle, Clock, Wifi, WifiOff } from "lucide-react";

interface EnhancedAnnotationControlsProps {
  fileId: string;
  pageNumber: number;
  annotations: Annotation[];
  onProcessingComplete?: (results: any[]) => void;
}

export const EnhancedAnnotationControls: React.FC<EnhancedAnnotationControlsProps> = ({
  fileId,
  pageNumber,
  annotations,
  onProcessingComplete
}) => {
  const {
    processAnnotations,
    retryProcessing,
    cancelProcessing,
    processingState,
    connectionHealth,
    getCurrentBatch
  } = useBatchProcessing({ fileId, pageNumber });

  const { activeBatches } = useEnhancedWebSocket();

  const handleProcess = useCallback(async () => {
    try {
      await processAnnotations(annotations);
    } catch (error) {
      console.error('Processing failed:', error);
    }
  }, [processAnnotations, annotations]);

  const currentBatch = getCurrentBatch();

  const processingDisplay = useMemo(() => {
    if (!processingState.isProcessing && !processingState.error) {
      return (
        <button
          onClick={handleProcess}
          disabled={annotations.length === 0}
          className="w-full px-4 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:bg-gray-300"
        >
          Process {annotations.length} Annotations
        </button>
      );
    }

    if (processingState.error) {
      return (
        <div className="space-y-2">
          <div className="flex items-center space-x-2 text-red-600 bg-red-50 p-3 rounded-lg">
            <AlertCircle size={16} />
            <span className="text-sm">{processingState.error}</span>
          </div>
          <div className="flex space-x-2">
            <button
              onClick={() => retryProcessing(true)}
              className="flex-1 px-3 py-2 bg-orange-600 text-white rounded hover:bg-orange-700"
            >
              Retry Failed
            </button>
            <button
              onClick={() => retryProcessing(false)}
              className="flex-1 px-3 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"
            >
              Retry All
            </button>
          </div>
        </div>
      );
    }

    return (
      <div className="space-y-3">
        {/* Progress bar */}
        <div className="w-full bg-gray-200 rounded-full h-2">
          <div
            className="bg-blue-600 h-2 rounded-full transition-all duration-300"
            style={{ width: `${processingState.progress}%` }}
          />
        </div>

        {/* Status display */}
        <div className="flex items-center justify-between text-sm">
          <span className="text-gray-600">{processingState.currentStage}</span>
          <span className="font-medium">{Math.round(processingState.progress)}%</span>
        </div>

        {/* Connection status */}
        <div className="flex items-center space-x-2 text-xs">
          {connectionHealth.isConnected ? (
            <>
              <Wifi size={12} className="text-green-600" />
              <span className="text-green-600">Real-time updates</span>
            </>
          ) : (
            <>
              <WifiOff size={12} className="text-orange-600" />
              <span className="text-orange-600">Polling for updates</span>
            </>
          )}
        </div>

        {/* Cancel button */}
        <button
          onClick={cancelProcessing}
          className="w-full px-3 py-2 text-red-600 border border-red-200 rounded hover:bg-red-50"
        >
          Cancel Processing
        </button>
      </div>
    );
  }, [
    processingState,
    annotations.length,
    handleProcess,
    retryProcessing,
    cancelProcessing,
    connectionHealth
  ]);

  // Display batch results
  const batchResults = useMemo(() => {
    if (!currentBatch || currentBatch.status !== 'completed') return null;

    const results = Object.values(currentBatch.items);
    const successful = results.filter(item => item.status === 'completed');
    const failed = results.filter(item => item.status === 'failed');

    return (
      <div className="mt-4 p-3 bg-green-50 border border-green-200 rounded-lg">
        <div className="flex items-center space-x-2 mb-2">
          <CheckCircle size={16} className="text-green-600" />
          <span className="font-medium text-green-800">Processing Complete</span>
        </div>
        <div className="text-sm text-green-700">
          {successful.length} successful, {failed.length} failed
        </div>
        {failed.length > 0 && (
          <button
            onClick={() => retryProcessing(true)}
            className="mt-2 text-xs text-blue-600 hover:text-blue-800"
          >
            Retry failed items
          </button>
        )}
      </div>
    );
  }, [currentBatch, retryProcessing]);

  return (
    <div className="batch-processing-controls">
      {processingDisplay}
      {batchResults}
    </div>
  );
};
```

This comprehensive implementation provides:

1. **WebSocket + REST API Fallback**: Seamless switching between real-time updates and polling
2. **Multiple Batch Management**: Handle concurrent batches with individual tracking
3. **Comprehensive Error Handling**: Detailed error messages with recovery options
4. **Well-Organized Message Structure**: Standardized message formats for all communications
5. **Job Polling Service**: Automatic polling when WebSocket is unavailable
6. **Batch Status APIs**: Complete REST endpoints for batch management
7. **Enhanced UI Components**: Smart controls with connection status and progress tracking

The system gracefully handles network issues, provides excellent user feedback, and maintains state consistency across connection interruptions.