# Stable WebSocket Integration Patterns for ADEOS

## Overview

This document outlines robust WebSocket integration patterns specifically designed for ADEOS annotation processing system. These patterns ensure stable real-time communication, efficient state management, and graceful error handling.

## Core Integration Patterns

### 1. Optimistic State Management Pattern

This pattern provides immediate UI feedback while maintaining consistency with server state.

```typescript
// hooks/useOptimisticProcessing.ts
import { useRef, useCallback, useState } from 'react';

interface OptimisticState<T> {
  current: T;
  isOptimistic: boolean;
  timeout?: NodeJS.Timeout;
}

export const useOptimisticProcessing = <T>(
  initialState: T,
  timeoutMs: number = 5000
) => {
  const [state, setState] = useState<OptimisticState<T>>({
    current: initialState,
    isOptimistic: false
  });

  const setOptimistic = useCallback((value: T) => {
    // Clear existing timeout
    if (state.timeout) {
      clearTimeout(state.timeout);
    }

    // Set optimistic state with timeout
    const timeout = setTimeout(() => {
      setState(prev => ({
        ...prev,
        isOptimistic: false,
        timeout: undefined
      }));
    }, timeoutMs);

    setState({
      current: value,
      isOptimistic: true,
      timeout
    });
  }, [timeoutMs, state.timeout]);

  const confirmState = useCallback((value: T) => {
    if (state.timeout) {
      clearTimeout(state.timeout);
    }
    
    setState({
      current: value,
      isOptimistic: false,
      timeout: undefined
    });
  }, [state.timeout]);

  const revertOptimistic = useCallback(() => {
    if (state.timeout) {
      clearTimeout(state.timeout);
    }
    
    setState(prev => ({
      current: initialState,
      isOptimistic: false,
      timeout: undefined
    }));
  }, [initialState, state.timeout]);

  return {
    value: state.current,
    isOptimistic: state.isOptimistic,
    setOptimistic,
    confirmState,
    revertOptimistic
  };
};
```

### 2. Batch Processing State Pattern

Manages complex batch operations with individual item tracking.

```typescript
// hooks/useBatchProcessing.ts
import { useState, useCallback, useRef } from 'react';

interface BatchItem {
  id: string;
  status: 'pending' | 'processing' | 'completed' | 'failed';
  result?: any;
  error?: string;
  progress?: number;
}

interface BatchState {
  id: string;
  items: Record<string, BatchItem>;
  status: 'idle' | 'processing' | 'completed' | 'failed';
  progress: number;
  startTime?: Date;
  endTime?: Date;
}

export const useBatchProcessing = () => {
  const [batches, setBatches] = useState<Record<string, BatchState>>({});
  const subscribersRef = useRef<Record<string, Set<Function>>>({});

  const createBatch = useCallback((batchId: string, itemIds: string[]) => {
    const items: Record<string, BatchItem> = {};
    itemIds.forEach(id => {
      items[id] = { id, status: 'pending' };
    });

    setBatches(prev => ({
      ...prev,
      [batchId]: {
        id: batchId,
        items,
        status: 'processing',
        progress: 0,
        startTime: new Date()
      }
    }));

    // Initialize subscribers for this batch
    subscribersRef.current[batchId] = new Set();
  }, []);

  const updateBatchItem = useCallback((
    batchId: string, 
    itemId: string, 
    updates: Partial<BatchItem>
  ) => {
    setBatches(prev => {
      const batch = prev[batchId];
      if (!batch) return prev;

      const updatedItems = {
        ...batch.items,
        [itemId]: { ...batch.items[itemId], ...updates }
      };

      // Calculate batch progress
      const totalItems = Object.keys(updatedItems).length;
      const completedItems = Object.values(updatedItems).filter(
        item => item.status === 'completed' || item.status === 'failed'
      ).length;
      const progress = (completedItems / totalItems) * 100;

      // Determine batch status
      const allCompleted = Object.values(updatedItems).every(
        item => item.status === 'completed' || item.status === 'failed'
      );
      const hasFailures = Object.values(updatedItems).some(
        item => item.status === 'failed'
      );

      const updatedBatch: BatchState = {
        ...batch,
        items: updatedItems,
        progress,
        status: allCompleted 
          ? (hasFailures ? 'failed' : 'completed')
          : 'processing',
        endTime: allCompleted ? new Date() : undefined
      };

      // Notify subscribers
      subscribersRef.current[batchId]?.forEach(callback => {
        callback(updatedBatch);
      });

      return {
        ...prev,
        [batchId]: updatedBatch
      };
    });
  }, []);

  const subscribeToBatch = useCallback((
    batchId: string, 
    callback: (batch: BatchState) => void
  ) => {
    if (!subscribersRef.current[batchId]) {
      subscribersRef.current[batchId] = new Set();
    }
    
    subscribersRef.current[batchId].add(callback);

    // Return unsubscribe function
    return () => {
      subscribersRef.current[batchId]?.delete(callback);
    };
  }, []);

  const getBatch = useCallback((batchId: string) => {
    return batches[batchId];
  }, [batches]);

  const clearBatch = useCallback((batchId: string) => {
    setBatches(prev => {
      const { [batchId]: removed, ...rest } = prev;
      return rest;
    });
    
    // Clean up subscribers
    delete subscribersRef.current[batchId];
  }, []);

  return {
    batches,
    createBatch,
    updateBatchItem,
    subscribeToBatch,
    getBatch,
    clearBatch
  };
};
```

### 3. Resilient WebSocket Connection Pattern

Ensures stable WebSocket connections with automatic reconnection and message queuing.

```typescript
// hooks/useResilientWebSocket.ts
import { useRef, useCallback, useEffect, useState } from 'react';

interface WebSocketConfig {
  url: string;
  reconnectInterval?: number;
  maxReconnectAttempts?: number;
  heartbeatInterval?: number;
  messageQueueSize?: number;
}

interface ConnectionState {
  status: 'connecting' | 'connected' | 'disconnected' | 'error';
  lastConnected?: Date;
  reconnectAttempts: number;
  latency?: number;
}

export const useResilientWebSocket = (config: WebSocketConfig) => {
  const {
    url,
    reconnectInterval = 3000,
    maxReconnectAttempts = 5,
    heartbeatInterval = 30000,
    messageQueueSize = 100
  } = config;

  const wsRef = useRef<WebSocket | null>(null);
  const reconnectTimeoutRef = useRef<NodeJS.Timeout>();
  const heartbeatTimeoutRef = useRef<NodeJS.Timeout>();
  const messageQueueRef = useRef<Array<any>>([]);
  const handlersRef = useRef<Map<string, Set<Function>>>(new Map());
  const lastPingRef = useRef<number>(0);

  const [connectionState, setConnectionState] = useState<ConnectionState>({
    status: 'disconnected',
    reconnectAttempts: 0
  });

  const connect = useCallback(() => {
    if (wsRef.current?.readyState === WebSocket.OPEN) return;

    setConnectionState(prev => ({ 
      ...prev, 
      status: 'connecting' 
    }));

    try {
      wsRef.current = new WebSocket(url);

      wsRef.current.onopen = () => {
        setConnectionState(prev => ({
          ...prev,
          status: 'connected',
          lastConnected: new Date(),
          reconnectAttempts: 0
        }));

        // Send queued messages
        const queue = messageQueueRef.current.splice(0);
        queue.forEach(message => {
          wsRef.current?.send(JSON.stringify(message));
        });

        // Start heartbeat
        startHeartbeat();
      };

      wsRef.current.onmessage = (event) => {
        try {
          const message = JSON.parse(event.data);
          
          // Handle pong messages for latency calculation
          if (message.type === 'pong') {
            const latency = Date.now() - lastPingRef.current;
            setConnectionState(prev => ({ ...prev, latency }));
            return;
          }

          // Route message to handlers
          const handlers = handlersRef.current.get(message.type) || new Set();
          handlers.forEach(handler => handler(message));
          
          // Also route to wildcard handlers
          const wildcardHandlers = handlersRef.current.get('*') || new Set();
          wildcardHandlers.forEach(handler => handler(message));

        } catch (error) {
          console.error('Failed to parse WebSocket message:', error);
        }
      };

      wsRef.current.onclose = (event) => {
        setConnectionState(prev => ({ ...prev, status: 'disconnected' }));
        stopHeartbeat();
        
        if (!event.wasClean) {
          attemptReconnect();
        }
      };

      wsRef.current.onerror = () => {
        setConnectionState(prev => ({ ...prev, status: 'error' }));
        attemptReconnect();
      };

    } catch (error) {
      console.error('WebSocket connection failed:', error);
      attemptReconnect();
    }
  }, [url]);

  const attemptReconnect = useCallback(() => {
    setConnectionState(prev => {
      if (prev.reconnectAttempts >= maxReconnectAttempts) {
        return { ...prev, status: 'error' };
      }

      // Exponential backoff
      const delay = reconnectInterval * Math.pow(2, prev.reconnectAttempts);
      
      reconnectTimeoutRef.current = setTimeout(connect, delay);
      
      return {
        ...prev,
        reconnectAttempts: prev.reconnectAttempts + 1
      };
    });
  }, [connect, maxReconnectAttempts, reconnectInterval]);

  const startHeartbeat = useCallback(() => {
    const sendPing = () => {
      if (wsRef.current?.readyState === WebSocket.OPEN) {
        lastPingRef.current = Date.now();
        wsRef.current.send(JSON.stringify({ type: 'ping', timestamp: lastPingRef.current }));
        
        heartbeatTimeoutRef.current = setTimeout(sendPing, heartbeatInterval);
      }
    };

    heartbeatTimeoutRef.current = setTimeout(sendPing, heartbeatInterval);
  }, [heartbeatInterval]);

  const stopHeartbeat = useCallback(() => {
    if (heartbeatTimeoutRef.current) {
      clearTimeout(heartbeatTimeoutRef.current);
      heartbeatTimeoutRef.current = undefined;
    }
  }, []);

  const send = useCallback((message: any) => {
    if (wsRef.current?.readyState === WebSocket.OPEN) {
      wsRef.current.send(JSON.stringify(message));
    } else {
      // Queue message for later delivery
      if (messageQueueRef.current.length >= messageQueueSize) {
        messageQueueRef.current.shift(); // Remove oldest message
      }
      messageQueueRef.current.push(message);
    }
  }, [messageQueueSize]);

  const subscribe = useCallback((
    messageType: string, 
    handler: (message: any) => void
  ) => {
    if (!handlersRef.current.has(messageType)) {
      handlersRef.current.set(messageType, new Set());
    }
    
    handlersRef.current.get(messageType)!.add(handler);

    // Return unsubscribe function
    return () => {
      handlersRef.current.get(messageType)?.delete(handler);
    };
  }, []);

  const disconnect = useCallback(() => {
    if (reconnectTimeoutRef.current) {
      clearTimeout(reconnectTimeoutRef.current);
    }
    
    stopHeartbeat();
    
    if (wsRef.current) {
      wsRef.current.close(1000, 'Client disconnect');
      wsRef.current = null;
    }
    
    setConnectionState({
      status: 'disconnected',
      reconnectAttempts: 0
    });
  }, [stopHeartbeat]);

  // Auto-connect on mount
  useEffect(() => {
    connect();
    return disconnect;
  }, [connect, disconnect]);

  return {
    connectionState,
    send,
    subscribe,
    connect,
    disconnect,
    isConnected: connectionState.status === 'connected'
  };
};
```

### 4. Smart State Synchronization Pattern

Synchronizes component state with WebSocket updates intelligently.

```typescript
// hooks/useSmartStateSync.ts
import { useEffect, useRef, useCallback } from 'react';

interface StateSyncConfig<T> {
  localState: T;
  setLocalState: (state: T | ((prev: T) => T)) => void;
  wsSubscribe: (handler: (data: any) => void) => () => void;
  stateKey: string;
  conflictResolver?: (local: T, remote: T) => T;
}

export const useSmartStateSync = <T>({
  localState,
  setLocalState,
  wsSubscribe,
  stateKey,
  conflictResolver
}: StateSyncConfig<T>) => {
  const lastRemoteUpdateRef = useRef<number>(0);
  const pendingLocalChangesRef = useRef<boolean>(false);
  const localChangeTimeoutRef = useRef<NodeJS.Timeout>();

  // Mark local changes to prevent conflicts
  const markLocalChange = useCallback(() => {
    pendingLocalChangesRef.current = true;
    
    if (localChangeTimeoutRef.current) {
      clearTimeout(localChangeTimeoutRef.current);
    }
    
    // Clear pending flag after timeout
    localChangeTimeoutRef.current = setTimeout(() => {
      pendingLocalChangesRef.current = false;
    }, 2000);
  }, []);

  // Enhanced setState that tracks local changes
  const setSyncedState = useCallback((
    updater: T | ((prev: T) => T)
  ) => {
    markLocalChange();
    setLocalState(updater);
  }, [setLocalState, markLocalChange]);

  // Subscribe to WebSocket updates
  useEffect(() => {
    const unsubscribe = wsSubscribe((message) => {
      if (message.stateKey !== stateKey) return;

      const remoteState = message.data;
      const timestamp = message.timestamp || Date.now();

      // Skip if we have pending local changes
      if (pendingLocalChangesRef.current) {
        return;
      }

      // Skip if remote update is older than last one
      if (timestamp <= lastRemoteUpdateRef.current) {
        return;
      }

      lastRemoteUpdateRef.current = timestamp;

      // Apply conflict resolution if provided
      if (conflictResolver) {
        const resolvedState = conflictResolver(localState, remoteState);
        setLocalState(resolvedState);
      } else {
        setLocalState(remoteState);
      }
    });

    return unsubscribe;
  }, [wsSubscribe, stateKey, conflictResolver, localState, setLocalState]);

  return {
    setSyncedState,
    hasPendingChanges: pendingLocalChangesRef.current
  };
};
```

### 5. Annotation Processing Integration Pattern

Specific pattern for ADEOS annotation processing workflow.

```typescript
// hooks/useAnnotationProcessing.ts
import { useCallback, useRef } from 'react';
import { useResilientWebSocket } from './useResilientWebSocket';
import { useBatchProcessing } from './useBatchProcessing';
import { useOptimisticProcessing } from './useOptimisticProcessing';

interface AnnotationProcessingConfig {
  wsUrl: string;
  fileId: string;
  pageNumber: number;
}

export const useAnnotationProcessing = ({
  wsUrl,
  fileId,
  pageNumber
}: AnnotationProcessingConfig) => {
  
  const { send, subscribe, isConnected } = useResilientWebSocket({ url: wsUrl });
  const { createBatch, updateBatchItem, subscribeToBatch, getBatch } = useBatchProcessing();
  const processingStateRef = useRef<Map<string, any>>(new Map());

  // Process annotations with optimistic state management
  const processAnnotations = useCallback(async (annotations: Annotation[]) => {
    const batchId = `${fileId}-${pageNumber}-${Date.now()}`;
    const annotationIds = annotations.map(a => a.id);

    // Create batch tracking
    createBatch(batchId, annotationIds);

    // Set optimistic processing state
    annotations.forEach(annotation => {
      processingStateRef.current.set(annotation.id, {
        status: 'processing',
        batchId,
        startTime: new Date()
      });
    });

    try {
      // Send batch processing request
      send({
        type: 'process_batch',
        batch_id: batchId,
        file_id: fileId,
        page_number: pageNumber,
        annotations: annotations.map(a => ({
          id: a.id,
          type: a.type,
          bbox: a.bbox,
          content: a.content
        }))
      });

      return batchId;

    } catch (error) {
      // Revert optimistic state on error
      annotationIds.forEach(id => {
        processingStateRef.current.delete(id);
      });
      throw error;
    }
  }, [send, fileId, pageNumber, createBatch]);

  // Subscribe to batch progress updates
  useEffect(() => {
    const unsubscribe = subscribe('batch_progress', (message) => {
      if (message.file_id === fileId && message.page_number === pageNumber) {
        updateBatchItem(
          message.batch_id,
          message.annotation_id,
          {
            status: 'processing',
            progress: message.progress
          }
        );
      }
    });

    return unsubscribe;
  }, [subscribe, fileId, pageNumber, updateBatchItem]);

  // Subscribe to batch completion
  useEffect(() => {
    const unsubscribe = subscribe('batch_item_completed', (message) => {
      if (message.file_id === fileId && message.page_number === pageNumber) {
        updateBatchItem(
          message.batch_id,
          message.annotation_id,
          {
            status: message.success ? 'completed' : 'failed',
            result: message.result,
            error: message.error,
            progress: 100
          }
        );

        // Update local processing state
        processingStateRef.current.set(message.annotation_id, {
          status: message.success ? 'completed' : 'failed',
          result: message.result,
          error: message.error,
          endTime: new Date()
        });
      }
    });

    return unsubscribe;
  }, [subscribe, fileId, pageNumber, updateBatchItem]);

  // Get processing state for annotation
  const getAnnotationState = useCallback((annotationId: string) => {
    return processingStateRef.current.get(annotationId);
  }, []);

  // Check if any annotations are processing
  const hasProcessingAnnotations = useCallback(() => {
    return Array.from(processingStateRef.current.values()).some(
      state => state.status === 'processing'
    );
  }, []);

  return {
    processAnnotations,
    subscribeToBatch,
    getBatch,
    getAnnotationState,
    hasProcessingAnnotations,
    isConnected
  };
};
```

## Implementation Guidelines

### 1. Error Recovery Strategy

```typescript
// Error boundaries and recovery patterns
const withErrorRecovery = (Component: React.ComponentType<any>) => {
  return (props: any) => {
    const [hasError, setHasError] = useState(false);
    const [retryCount, setRetryCount] = useState(0);

    const resetError = useCallback(() => {
      setHasError(false);
      setRetryCount(prev => prev + 1);
    }, []);

    if (hasError) {
      return (
        <div className="error-recovery">
          <p>WebSocket connection failed</p>
          <button onClick={resetError}>
            Retry ({retryCount}/3)
          </button>
        </div>
      );
    }

    return (
      <ErrorBoundary onError={() => setHasError(true)}>
        <Component {...props} />
      </ErrorBoundary>
    );
  };
};
```

### 2. Performance Monitoring

```typescript
// Performance monitoring for WebSocket operations
export const useWebSocketPerformance = () => {
  const metricsRef = useRef({
    messagesSent: 0,
    messagesReceived: 0,
    averageLatency: 0,
    connectionUptime: 0,
    reconnections: 0
  });

  const trackMessage = useCallback((type: 'sent' | 'received', latency?: number) => {
    metricsRef.current[`messages${type === 'sent' ? 'Sent' : 'Received'}`]++;
    
    if (latency && type === 'received') {
      const current = metricsRef.current.averageLatency;
      const count = metricsRef.current.messagesReceived;
      metricsRef.current.averageLatency = (current * (count - 1) + latency) / count;
    }
  }, []);

  return { metrics: metricsRef.current, trackMessage };
};
```

### 3. State Persistence

```typescript
// Persist WebSocket state across sessions
export const usePersistedWebSocketState = (key: string) => {
  const [state, setState] = useState(() => {
    try {
      const saved = localStorage.getItem(`ws_state_${key}`);
      return saved ? JSON.parse(saved) : {};
    } catch {
      return {};
    }
  });

  useEffect(() => {
    try {
      localStorage.setItem(`ws_state_${key}`, JSON.stringify(state));
    } catch (error) {
      console.warn('Failed to persist WebSocket state:', error);
    }
  }, [key, state]);

  return [state, setState];
};
```

These patterns provide a robust foundation for WebSocket integration in the ADEOS system, ensuring stability, performance, and excellent user experience even under challenging network conditions.