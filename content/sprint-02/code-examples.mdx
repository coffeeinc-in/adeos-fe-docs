# Implementation Code Examples

## Next.js 15 Frontend Implementation

### Types Definition (types/websocket.ts)

```typescript
export interface JobStatus {
  job_id: string;
  status: 'pending' | 'processing' | 'completed' | 'failed';
  progress: number;
  current_task: string;
  results?: ExtractionResults;
  error?: string;
  created_at: string;
  updated_at: string;
}

export interface ExtractionResults {
  text_extraction?: {
    content: string;
    metadata: { pages: number; characters: number };
  };
  table_extraction?: {
    tables: Array<{
      data: any[][];
      headers: string[];
      position: { page: number; coordinates: number[] };
    }>;
  };
  diagram_extraction?: {
    images: Array<{
      url: string;
      description: string;
      type: string;
      position: { page: number; coordinates: number[] };
    }>;
  };
}

export interface WebSocketMessage {
  type: 'progress' | 'result' | 'error' | 'connection';
  job_id: string;
  data: any;
  timestamp: string;
}
```

### WebSocket Hook (hooks/useWebSocket.ts)

```typescript
'use client';

import { useEffect, useRef, useState, useCallback } from 'react';
import { JobStatus, WebSocketMessage } from '../types/websocket';

interface UseWebSocketOptions {
  url: string;
  jobId?: string;
  token?: string;
  onMessage?: (message: WebSocketMessage) => void;
  onError?: (error: Event) => void;
  reconnectInterval?: number;
  maxReconnectAttempts?: number;
}

export const useWebSocket = ({
  url,
  jobId,
  token,
  onMessage,
  onError,
  reconnectInterval = 3000,
  maxReconnectAttempts = 5
}: UseWebSocketOptions) => {
  const [isConnected, setIsConnected] = useState(false);
  const [connectionState, setConnectionState] = useState<'connecting' | 'connected' | 'disconnected' | 'reconnecting'>('disconnected');
  const [jobStatus, setJobStatus] = useState<JobStatus | null>(null);
  
  const ws = useRef<WebSocket | null>(null);
  const reconnectTimeoutRef = useRef<NodeJS.Timeout>();
  const reconnectAttempts = useRef(0);

  const connect = useCallback(() => {
    if (!jobId) return;

    setConnectionState('connecting');
    
    const wsUrl = `${url}?job_id=${jobId}&token=${token || ''}`;
    ws.current = new WebSocket(wsUrl);

    ws.current.onopen = () => {
      setIsConnected(true);
      setConnectionState('connected');
      reconnectAttempts.current = 0;
      console.log(`WebSocket connected for job: ${jobId}`);
    };

    ws.current.onmessage = (event) => {
      try {
        const message: WebSocketMessage = JSON.parse(event.data);
        
        if (message.type === 'progress' || message.type === 'result') {
          setJobStatus(message.data);
        }
        
        onMessage?.(message);
      } catch (error) {
        console.error('Failed to parse WebSocket message:', error);
      }
    };

    ws.current.onclose = () => {
      setIsConnected(false);
      setConnectionState('disconnected');
      
      // Attempt reconnection if not manually closed
      if (reconnectAttempts.current < maxReconnectAttempts) {
        setConnectionState('reconnecting');
        reconnectAttempts.current++;
        
        reconnectTimeoutRef.current = setTimeout(() => {
          connect();
        }, reconnectInterval * Math.pow(2, reconnectAttempts.current - 1)); // Exponential backoff
      }
    };

    ws.current.onerror = (error) => {
      console.error('WebSocket error:', error);
      onError?.(error);
    };
  }, [url, jobId, token, onMessage, onError, reconnectInterval, maxReconnectAttempts]);

  const disconnect = useCallback(() => {
    if (reconnectTimeoutRef.current) {
      clearTimeout(reconnectTimeoutRef.current);
    }
    
    if (ws.current) {
      ws.current.close();
      ws.current = null;
    }
    
    setIsConnected(false);
    setConnectionState('disconnected');
  }, []);

  const sendMessage = useCallback((message: any) => {
    if (ws.current && ws.current.readyState === WebSocket.OPEN) {
      ws.current.send(JSON.stringify(message));
    }
  }, []);

  useEffect(() => {
    if (jobId) {
      connect();
    }

    return () => {
      disconnect();
    };
  }, [jobId, connect, disconnect]);

  return {
    isConnected,
    connectionState,
    jobStatus,
    sendMessage,
    disconnect
  };
};
```

### Upload Form Component (components/UploadForm.tsx)

```typescript
'use client';

import { useState, useCallback } from 'react';
import { useDropzone } from 'react-dropzone';

interface UploadFormProps {
  onUploadSuccess: (jobId: string) => void;
  onUploadError: (error: string) => void;
}

export const UploadForm: React.FC<UploadFormProps> = ({
  onUploadSuccess,
  onUploadError
}) => {
  const [isUploading, setIsUploading] = useState(false);
  const [uploadProgress, setUploadProgress] = useState(0);

  const uploadFile = async (file: File) => {
    setIsUploading(true);
    setUploadProgress(0);

    try {
      const formData = new FormData();
      formData.append('file', file);
      formData.append('extraction_types', JSON.stringify(['text', 'table', 'diagram']));

      const xhr = new XMLHttpRequest();
      
      return new Promise<string>((resolve, reject) => {
        xhr.upload.onprogress = (event) => {
          if (event.lengthComputable) {
            const progress = (event.loaded / event.total) * 100;
            setUploadProgress(progress);
          }
        };

        xhr.onload = () => {
          if (xhr.status === 200) {
            const response = JSON.parse(xhr.responseText);
            resolve(response.job_id);
          } else {
            reject(new Error(`Upload failed: ${xhr.statusText}`));
          }
        };

        xhr.onerror = () => reject(new Error('Upload failed'));

        xhr.open('POST', '/api/process');
        xhr.send(formData);
      });

    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Upload failed';
      onUploadError(errorMessage);
      throw error;
    } finally {
      setIsUploading(false);
      setUploadProgress(0);
    }
  };

  const onDrop = useCallback(async (acceptedFiles: File[]) => {
    if (acceptedFiles.length === 0) return;

    const file = acceptedFiles[0];
    
    try {
      const jobId = await uploadFile(file);
      onUploadSuccess(jobId);
    } catch (error) {
      console.error('Upload error:', error);
    }
  }, [onUploadSuccess, onUploadError]);

  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    onDrop,
    accept: {
      'application/pdf': ['.pdf'],
      'application/msword': ['.doc'],
      'application/vnd.openxmlformats-officedocument.wordprocessingml.document': ['.docx'],
      'image/*': ['.png', '.jpg', '.jpeg']
    },
    maxFiles: 1,
    disabled: isUploading
  });

  return (
    <div className="w-full max-w-lg mx-auto">
      <div
        {...getRootProps()}
        className={`border-2 border-dashed rounded-lg p-8 text-center cursor-pointer transition-colors
          ${isDragActive ? 'border-blue-400 bg-blue-50' : 'border-gray-300 hover:border-gray-400'}
          ${isUploading ? 'cursor-not-allowed opacity-50' : ''}
        `}
      >
        <input {...getInputProps()} />
        
        {isUploading ? (
          <div className="space-y-4">
            <div className="text-blue-600">Uploading...</div>
            <div className="w-full bg-gray-200 rounded-full h-2">
              <div
                className="bg-blue-600 h-2 rounded-full transition-all duration-300"
                style={{ width: `${uploadProgress}%` }}
              />
            </div>
            <div className="text-sm text-gray-500">{Math.round(uploadProgress)}%</div>
          </div>
        ) : isDragActive ? (
          <div className="text-blue-600">Drop the file here...</div>
        ) : (
          <div className="space-y-2">
            <div className="text-gray-600">
              Drag and drop a file here, or click to select
            </div>
            <div className="text-sm text-gray-500">
              Supports PDF, Word documents, and images
            </div>
          </div>
        )}
      </div>
    </div>
  );
};
```

### Process Status Component (components/ProcessStatus.tsx)

```typescript
'use client';

import { useWebSocket } from '../hooks/useWebSocket';
import { JobStatus } from '../types/websocket';

interface ProcessStatusProps {
  jobId: string;
  apiUrl: string;
  wsUrl: string;
}

export const ProcessStatus: React.FC<ProcessStatusProps> = ({
  jobId,
  apiUrl,
  wsUrl
}) => {
  const { isConnected, connectionState, jobStatus } = useWebSocket({
    url: wsUrl,
    jobId,
    onMessage: (message) => {
      console.log('WebSocket message:', message);
    },
    onError: (error) => {
      console.error('WebSocket error:', error);
    }
  });

  const getStatusColor = (status: string) => {
    switch (status) {
      case 'pending': return 'text-yellow-600 bg-yellow-100';
      case 'processing': return 'text-blue-600 bg-blue-100';
      case 'completed': return 'text-green-600 bg-green-100';
      case 'failed': return 'text-red-600 bg-red-100';
      default: return 'text-gray-600 bg-gray-100';
    }
  };

  const renderExtractionResults = () => {
    if (!jobStatus?.results) return null;

    const { results } = jobStatus;

    return (
      <div className="space-y-6">
        {results.text_extraction && (
          <div className="border rounded-lg p-4">
            <h3 className="font-semibold mb-2">Text Extraction</h3>
            <div className="text-sm text-gray-600 mb-2">
              Pages: {results.text_extraction.metadata.pages} | 
              Characters: {results.text_extraction.metadata.characters}
            </div>
            <div className="max-h-40 overflow-y-auto bg-gray-50 p-3 rounded text-sm">
              {results.text_extraction.content.substring(0, 500)}
              {results.text_extraction.content.length > 500 && '...'}
            </div>
          </div>
        )}

        {results.table_extraction && (
          <div className="border rounded-lg p-4">
            <h3 className="font-semibold mb-2">Table Extraction</h3>
            <div className="text-sm text-gray-600 mb-2">
              Found {results.table_extraction.tables.length} tables
            </div>
            {results.table_extraction.tables.map((table, index) => (
              <div key={index} className="mb-4 last:mb-0">
                <div className="text-sm font-medium mb-2">Table {index + 1}</div>
                <div className="overflow-x-auto">
                  <table className="min-w-full border border-gray-200 text-xs">
                    <thead>
                      <tr className="bg-gray-50">
                        {table.headers.map((header, i) => (
                          <th key={i} className="border border-gray-200 px-2 py-1">
                            {header}
                          </th>
                        ))}
                      </tr>
                    </thead>
                    <tbody>
                      {table.data.slice(0, 3).map((row, i) => (
                        <tr key={i}>
                          {row.map((cell, j) => (
                            <td key={j} className="border border-gray-200 px-2 py-1">
                              {cell}
                            </td>
                          ))}
                        </tr>
                      ))}
                    </tbody>
                  </table>
                  {table.data.length > 3 && (
                    <div className="text-xs text-gray-500 mt-1">
                      ... and {table.data.length - 3} more rows
                    </div>
                  )}
                </div>
              </div>
            ))}
          </div>
        )}

        {results.diagram_extraction && (
          <div className="border rounded-lg p-4">
            <h3 className="font-semibold mb-2">Diagram Extraction</h3>
            <div className="text-sm text-gray-600 mb-2">
              Found {results.diagram_extraction.images.length} images/diagrams
            </div>
            <div className="grid grid-cols-2 gap-4">
              {results.diagram_extraction.images.map((image, index) => (
                <div key={index} className="border rounded p-2">
                  <img 
                    src={image.url} 
                    alt={image.description}
                    className="w-full h-32 object-cover rounded mb-2"
                  />
                  <div className="text-xs text-gray-600">
                    <div><strong>Type:</strong> {image.type}</div>
                    <div><strong>Description:</strong> {image.description}</div>
                  </div>
                </div>
              ))}
            </div>
          </div>
        )}
      </div>
    );
  };

  return (
    <div className="w-full max-w-4xl mx-auto space-y-6">
      {/* Connection Status */}
      <div className="flex items-center space-x-2">
        <div className={`w-3 h-3 rounded-full ${
          isConnected ? 'bg-green-500' : 'bg-red-500'
        }`} />
        <span className="text-sm text-gray-600">
          Connection: {connectionState}
        </span>
      </div>

      {/* Job Status */}
      {jobStatus && (
        <div className="border rounded-lg p-6">
          <div className="flex items-center justify-between mb-4">
            <div className="flex items-center space-x-3">
              <span className={`px-3 py-1 rounded-full text-sm font-medium ${
                getStatusColor(jobStatus.status)
              }`}>
                {jobStatus.status.toUpperCase()}
              </span>
              <span className="text-sm text-gray-600">
                Job ID: {jobStatus.job_id}
              </span>
            </div>
            <div className="text-sm text-gray-500">
              {Math.round(jobStatus.progress)}%
            </div>
          </div>

          {/* Progress Bar */}
          <div className="mb-4">
            <div className="flex justify-between text-sm text-gray-600 mb-1">
              <span>{jobStatus.current_task}</span>
              <span>{Math.round(jobStatus.progress)}%</span>
            </div>
            <div className="w-full bg-gray-200 rounded-full h-2">
              <div
                className="bg-blue-600 h-2 rounded-full transition-all duration-300"
                style={{ width: `${jobStatus.progress}%` }}
              />
            </div>
          </div>

          {/* Error Display */}
          {jobStatus.error && (
            <div className="bg-red-50 border border-red-200 rounded p-3 mb-4">
              <div className="text-red-800 text-sm">
                <strong>Error:</strong> {jobStatus.error}
              </div>
            </div>
          )}

          {/* Results */}
          {jobStatus.status === 'completed' && renderExtractionResults()}
        </div>
      )}
    </div>
  );
};
```

### Main Page (app/page.tsx)

```typescript
'use client';

import { useState } from 'react';
import { UploadForm } from './components/UploadForm';
import { ProcessStatus } from './components/ProcessStatus';

export default function HomePage() {
  const [currentJobId, setCurrentJobId] = useState<string | null>(null);
  const [uploadError, setUploadError] = useState<string | null>(null);

  const apiUrl = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8000';
  const wsUrl = process.env.NEXT_PUBLIC_WS_URL || 'ws://localhost:8001';

  const handleUploadSuccess = (jobId: string) => {
    setCurrentJobId(jobId);
    setUploadError(null);
  };

  const handleUploadError = (error: string) => {
    setUploadError(error);
    setCurrentJobId(null);
  };

  const handleNewUpload = () => {
    setCurrentJobId(null);
    setUploadError(null);
  };

  return (
    <div className="min-h-screen bg-gray-50 py-12">
      <div className="container mx-auto px-4">
        <div className="text-center mb-12">
          <h1 className="text-4xl font-bold text-gray-900 mb-4">
            Document Processing System
          </h1>
          <p className="text-lg text-gray-600">
            Upload documents for text, table, and diagram extraction with real-time progress updates
          </p>
        </div>

        {uploadError && (
          <div className="max-w-lg mx-auto mb-6">
            <div className="bg-red-50 border border-red-200 rounded-lg p-4">
              <div className="text-red-800">
                <strong>Upload Error:</strong> {uploadError}
              </div>
            </div>
          </div>
        )}

        {!currentJobId ? (
          <UploadForm
            onUploadSuccess={handleUploadSuccess}
            onUploadError={handleUploadError}
          />
        ) : (
          <div className="space-y-6">
            <div className="text-center">
              <button
                onClick={handleNewUpload}
                className="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700"
              >
                Upload New File
              </button>
            </div>
            <ProcessStatus
              jobId={currentJobId}
              apiUrl={apiUrl}
              wsUrl={wsUrl}
            />
          </div>
        )}
      </div>
    </div>
  );
}
```

### Package.json for Frontend

```json
{
  "name": "document-processing-frontend",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@types/node": "^20",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "autoprefixer": "^10.0.1",
    "next": "15.0.0",
    "postcss": "^8",
    "react": "^18",
    "react-dom": "^18",
    "react-dropzone": "^14.2.3",
    "tailwindcss": "^3.3.0",
    "typescript": "^5"
  },
  "devDependencies": {
    "eslint": "^8",
    "eslint-config-next": "15.0.0"
  }
}
```

## WebSocket Server Implementation (Node.js)

### Main Server (src/index.js)

```javascript
const express = require('express');
const http = require('http');
const WebSocket = require('ws');
const cors = require('cors');
const RedisClient = require('./redis-client');
const WebSocketHandler = require('./websocket');
const MessageHandler = require('./message-handler');

class WebSocketServer {
  constructor() {
    this.app = express();
    this.server = http.createServer(this.app);
    this.wss = new WebSocket.Server({ server: this.server });
    this.redisClient = new RedisClient();
    this.messageHandler = new MessageHandler(this.redisClient);
    this.wsHandler = new WebSocketHandler(this.wss, this.redisClient, this.messageHandler);
    
    this.setupMiddleware();
    this.setupRoutes();
    this.setupWebSocket();
  }

  setupMiddleware() {
    this.app.use(cors({
      origin: process.env.ALLOWED_ORIGINS?.split(',') || ['http://localhost:3000'],
      credentials: true
    }));
    this.app.use(express.json());
  }

  setupRoutes() {
    this.app.get('/health', (req, res) => {
      res.json({ 
        status: 'healthy', 
        connections: this.wss.clients.size,
        uptime: process.uptime(),
        memory: process.memoryUsage()
      });
    });

    this.app.get('/connections', (req, res) => {
      const connections = Array.from(this.wss.clients).map(ws => ({
        id: ws.id,
        jobId: ws.jobId,
        state: ws.readyState,
        connected: ws.readyState === WebSocket.OPEN
      }));
      
      res.json({ connections, total: connections.length });
    });
  }

  setupWebSocket() {
    this.wss.on('connection', (ws, request) => {
      this.wsHandler.handleConnection(ws, request);
    });
  }

  async start() {
    try {
      await this.redisClient.connect();
      console.log('Connected to Redis');

      const port = process.env.PORT || 8001;
      this.server.listen(port, () => {
        console.log(`WebSocket server running on port ${port}`);
      });

      // Graceful shutdown
      process.on('SIGTERM', () => this.shutdown());
      process.on('SIGINT', () => this.shutdown());

    } catch (error) {
      console.error('Failed to start server:', error);
      process.exit(1);
    }
  }

  async shutdown() {
    console.log('Shutting down WebSocket server...');
    
    // Close all WebSocket connections
    this.wss.clients.forEach(ws => {
      ws.close(1001, 'Server shutting down');
    });

    // Close Redis connection
    await this.redisClient.disconnect();
    
    // Close HTTP server
    this.server.close(() => {
      console.log('Server shutdown complete');
      process.exit(0);
    });
  }
}

// Start the server
const server = new WebSocketServer();
server.start().catch(console.error);

module.exports = WebSocketServer;
```

### WebSocket Handler (src/websocket.js)

```javascript
const WebSocket = require('ws');
const url = require('url');
const { v4: uuidv4 } = require('uuid');

class WebSocketHandler {
  constructor(wss, redisClient, messageHandler) {
    this.wss = wss;
    this.redisClient = redisClient;
    this.messageHandler = messageHandler;
    this.connections = new Map(); // jobId -> Set of websockets
  }

  handleConnection(ws, request) {
    const query = url.parse(request.url, true).query;
    const jobId = query.job_id;
    const token = query.token;

    if (!jobId) {
      ws.close(1008, 'job_id parameter is required');
      return;
    }

    // Validate token if provided
    if (token && !this.validateToken(token)) {
      ws.close(1008, 'Invalid authentication token');
      return;
    }

    // Assign unique ID to connection
    ws.id = uuidv4();
    ws.jobId = jobId;
    ws.connectedAt = new Date();
    ws.isAlive = true;

    // Add to connections map
    if (!this.connections.has(jobId)) {
      this.connections.set(jobId, new Set());
    }
    this.connections.get(jobId).add(ws);

    console.log(`WebSocket connected: ${ws.id} for job: ${jobId}`);

    // Send connection confirmation
    this.sendMessage(ws, {
      type: 'connection',
      job_id: jobId,
      data: { 
        connection_id: ws.id,
        message: 'Connected successfully' 
      },
      timestamp: new Date().toISOString()
    });

    // Subscribe to Redis channels for this job
    this.subscribeToJob(jobId);

    // Set up message handlers
    ws.on('message', (data) => this.handleMessage(ws, data));
    ws.on('close', () => this.handleDisconnection(ws));
    ws.on('error', (error) => this.handleError(ws, error));
    ws.on('pong', () => { ws.isAlive = true; });

    // Send current job status if available
    this.sendCurrentJobStatus(ws, jobId);
  }

  handleMessage(ws, data) {
    try {
      const message = JSON.parse(data);
      console.log(`Message from ${ws.id}:`, message);

      switch (message.type) {
        case 'ping':
          this.sendMessage(ws, {
            type: 'pong',
            job_id: ws.jobId,
            data: { timestamp: new Date().toISOString() },
            timestamp: new Date().toISOString()
          });
          break;

        case 'subscribe_additional':
          // Allow clients to subscribe to additional job IDs
          if (message.job_id) {
            this.subscribeToJob(message.job_id);
          }
          break;

        default:
          console.log(`Unknown message type: ${message.type}`);
      }
    } catch (error) {
      console.error(`Error parsing message from ${ws.id}:`, error);
      this.sendMessage(ws, {
        type: 'error',
        job_id: ws.jobId,
        data: { error: 'Invalid message format' },
        timestamp: new Date().toISOString()
      });
    }
  }

  handleDisconnection(ws) {
    console.log(`WebSocket disconnected: ${ws.id}`);

    // Remove from connections map
    if (this.connections.has(ws.jobId)) {
      this.connections.get(ws.jobId).delete(ws);
      
      // Clean up empty job sets
      if (this.connections.get(ws.jobId).size === 0) {
        this.connections.delete(ws.jobId);
        this.unsubscribeFromJob(ws.jobId);
      }
    }
  }

  handleError(ws, error) {
    console.error(`WebSocket error for ${ws.id}:`, error);
  }

  async subscribeToJob(jobId) {
    const channels = [
      `progress:${jobId}`,
      `results:${jobId}`,
      `errors:${jobId}`
    ];

    for (const channel of channels) {
      await this.redisClient.subscribe(channel, (message) => {
        this.broadcastToJob(jobId, message);
      });
    }
  }

  async unsubscribeFromJob(jobId) {
    const channels = [
      `progress:${jobId}`,
      `results:${jobId}`,
      `errors:${jobId}`
    ];

    for (const channel of channels) {
      await this.redisClient.unsubscribe(channel);
    }
  }

  broadcastToJob(jobId, message) {
    const connections = this.connections.get(jobId);
    if (!connections) return;

    const parsedMessage = typeof message === 'string' ? JSON.parse(message) : message;
    
    connections.forEach(ws => {
      if (ws.readyState === WebSocket.OPEN) {
        this.sendMessage(ws, parsedMessage);
      }
    });
  }

  sendMessage(ws, message) {
    if (ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify(message));
    }
  }

  async sendCurrentJobStatus(ws, jobId) {
    try {
      const status = await this.redisClient.get(`job_status:${jobId}`);
      if (status) {
        this.sendMessage(ws, {
          type: 'progress',
          job_id: jobId,
          data: JSON.parse(status),
          timestamp: new Date().toISOString()
        });
      }
    } catch (error) {
      console.error(`Error fetching job status for ${jobId}:`, error);
    }
  }

  validateToken(token) {
    // Implement your token validation logic here
    // For example, JWT verification
    return true; // Placeholder
  }

  // Health check for connections
  startHeartbeat() {
    setInterval(() => {
      this.wss.clients.forEach(ws => {
        if (!ws.isAlive) {
          ws.terminate();
          return;
        }
        
        ws.isAlive = false;
        ws.ping();
      });
    }, 30000); // 30 seconds
  }
}

module.exports = WebSocketHandler;
```

### Redis Client (src/redis-client.js)

```javascript
const Redis = require('ioredis');

class RedisClient {
  constructor() {
    this.client = null;
    this.subscriber = null;
    this.publisher = null;
    this.subscriptions = new Map(); // channel -> callback
  }

  async connect() {
    const redisConfig = {
      host: process.env.REDIS_HOST || 'localhost',
      port: process.env.REDIS_PORT || 6379,
      password: process.env.REDIS_PASSWORD,
      db: process.env.REDIS_DB || 0,
      retryDelayOnFailover: 100,
      enableReadyCheck: false,
      maxRetriesPerRequest: null,
    };

    // Main client for general operations
    this.client = new Redis(redisConfig);
    
    // Separate clients for pub/sub (Redis requirement)
    this.subscriber = new Redis(redisConfig);
    this.publisher = new Redis(redisConfig);

    // Set up event handlers
    this.client.on('error', (error) => {
      console.error('Redis client error:', error);
    });

    this.subscriber.on('error', (error) => {
      console.error('Redis subscriber error:', error);
    });

    this.publisher.on('error', (error) => {
      console.error('Redis publisher error:', error);
    });

    // Handle subscription messages
    this.subscriber.on('message', (channel, message) => {
      const callback = this.subscriptions.get(channel);
      if (callback) {
        try {
          callback(message);
        } catch (error) {
          console.error(`Error in subscription callback for ${channel}:`, error);
        }
      }
    });

    await Promise.all([
      this.client.ping(),
      this.subscriber.ping(),
      this.publisher.ping()
    ]);

    console.log('Connected to Redis');
  }

  async disconnect() {
    if (this.client) await this.client.quit();
    if (this.subscriber) await this.subscriber.quit();
    if (this.publisher) await this.publisher.quit();
    console.log('Disconnected from Redis');
  }

  // General Redis operations
  async get(key) {
    return await this.client.get(key);
  }

  async set(key, value, ttl = null) {
    if (ttl) {
      return await this.client.setex(key, ttl, value);
    }
    return await this.client.set(key, value);
  }

  async del(key) {
    return await this.client.del(key);
  }

  async exists(key) {
    return await this.client.exists(key);
  }

  // Queue operations
  async lpush(key, ...values) {
    return await this.client.lpush(key, ...values);
  }

  async rpop(key) {
    return await this.client.rpop(key);
  }

  async llen(key) {
    return await this.client.llen(key);
  }

  async lrange(key, start, stop) {
    return await this.client.lrange(key, start, stop);
  }

  // Pub/Sub operations
  async subscribe(channel, callback) {
    this.subscriptions.set(channel, callback);
    await this.subscriber.subscribe(channel);
  }

  async unsubscribe(channel) {
    this.subscriptions.delete(channel);
    await this.subscriber.unsubscribe(channel);
  }

  async publish(channel, message) {
    const messageString = typeof message === 'object' 
      ? JSON.stringify(message) 
      : message;
    return await this.publisher.publish(channel, messageString);
  }

  // Hash operations
  async hset(key, field, value) {
    return await this.client.hset(key, field, value);
  }

  async hget(key, field) {
    return await this.client.hget(key, field);
  }

  async hgetall(key) {
    return await this.client.hgetall(key);
  }

  async hdel(key, ...fields) {
    return await this.client.hdel(key, ...fields);
  }

  // Set operations
  async sadd(key, ...members) {
    return await this.client.sadd(key, ...members);
  }

  async srem(key, ...members) {
    return await this.client.srem(key, ...members);
  }

  async smembers(key) {
    return await this.client.smembers(key);
  }

  // Utility methods
  async flushdb() {
    return await this.client.flushdb();
  }

  async ping() {
    return await this.client.ping();
  }
}

module.exports = RedisClient;
```

### Message Handler (src/message-handler.js)

```javascript
class MessageHandler {
  constructor(redisClient) {
    this.redisClient = redisClient;
  }

  async handleJobProgress(jobId, progressData) {
    try {
      // Store current job status
      await this.redisClient.set(
        `job_status:${jobId}`, 
        JSON.stringify(progressData),
        3600 // 1 hour TTL
      );

      // Publish progress update
      const message = {
        type: 'progress',
        job_id: jobId,
        data: progressData,
        timestamp: new Date().toISOString()
      };

      await this.redisClient.publish(`progress:${jobId}`, message);
      
      console.log(`Progress update sent for job ${jobId}: ${progressData.progress}%`);
    } catch (error) {
      console.error(`Error handling job progress for ${jobId}:`, error);
    }
  }

  async handleJobResult(jobId, resultData) {
    try {
      // Update job status to completed
      const statusData = {
        job_id: jobId,
        status: 'completed',
        progress: 100,
        current_task: 'Processing complete',
        results: resultData,
        updated_at: new Date().toISOString()
      };

      await this.redisClient.set(
        `job_status:${jobId}`, 
        JSON.stringify(statusData),
        3600 // 1 hour TTL
      );

      // Publish result
      const message = {
        type: 'result',
        job_id: jobId,
        data: statusData,
        timestamp: new Date().toISOString()
      };

      await this.redisClient.publish(`results:${jobId}`, message);
      
      console.log(`Results sent for job ${jobId}`);
    } catch (error) {
      console.error(`Error handling job result for ${jobId}:`, error);
    }
  }

  async handleJobError(jobId, errorData) {
    try {
      // Update job status to failed
      const statusData = {
        job_id: jobId,
        status: 'failed',
        progress: 0,
        current_task: 'Processing failed',
        error: errorData.message || 'Unknown error',
        updated_at: new Date().toISOString()
      };

      await this.redisClient.set(
        `job_status:${jobId}`, 
        JSON.stringify(statusData),
        3600 // 1 hour TTL
      );

      // Publish error
      const message = {
        type: 'error',
        job_id: jobId,
        data: statusData,
        timestamp: new Date().toISOString()
      };

      await this.redisClient.publish(`errors:${jobId}`, message);
      
      console.log(`Error sent for job ${jobId}: ${errorData.message}`);
    } catch (error) {
      console.error(`Error handling job error for ${jobId}:`, error);
    }
  }

  async getJobStatus(jobId) {
    try {
      const status = await this.redisClient.get(`job_status:${jobId}`);
      return status ? JSON.parse(status) : null;
    } catch (error) {
      console.error(`Error getting job status for ${jobId}:`, error);
      return null;
    }
  }

  async deleteJobData(jobId) {
    try {
      await this.redisClient.del(`job_status:${jobId}`);
      console.log(`Job data deleted for ${jobId}`);
    } catch (error) {
      console.error(`Error deleting job data for ${jobId}:`, error);
    }
  }
}

module.exports = MessageHandler;
```

### Package.json for WebSocket Server

```json
{
  "name": "websocket-server",
  "version": "1.0.0",
  "description": "WebSocket server for real-time document processing updates",
  "main": "src/index.js",
  "scripts": {
    "start": "node src/index.js",
    "dev": "nodemon src/index.js",
    "test": "jest",
    "lint": "eslint src/"
  },
  "dependencies": {
    "cors": "^2.8.5",
    "express": "^4.18.2",
    "ioredis": "^5.3.2",
    "uuid": "^9.0.1",
    "ws": "^8.14.2"
  },
  "devDependencies": {
    "eslint": "^8.52.0",
    "jest": "^29.7.0",
    "nodemon": "^3.0.1"
  },
  "engines": {
    "node": ">=18.0.0"
  }
}
```