# File Upload Flow

Complete flow from file selection to navigation, featuring client-side parsing, thumbnail generation, and optimized page selection.

## Flow Diagram

```mermaid
graph TD
    A[User: Click Upload] --> B[Input: Select File]
    B --> C{File Type?}

    C -->|PDF| D[pdf.dist: Parse PDF]
    C -->|DOCX| E[docx lib: Parse DOCX]
    C -->|ODF| F[odf lib: Parse ODF]
    C -->|Image| G[Image: Direct Load]

    D --> H[Extract Page Count]
    E --> H
    F --> H
    G --> I[Single Page]

    H --> J[Generate Thumbnails]
    I --> J

    J --> K[Render Thumbnail Grid]
    K --> L[Show Selection UI]

    L --> M{Selection Mode}
    M -->|Page Selection| N[Checkboxes per Page]
    M -->|Range Selection| O[Start/End Range Picker]

    N --> P[User: Select Pages]
    O --> Q[User: Set Range]

    P --> R[Validate Selection]
    Q --> R

    R --> S{Valid?}
    S -->|No| T[Show Error]
    T --> L
    S -->|Yes| U[Enable Submit Button]

    U --> V[User: Click Submit]
    V --> W[Prepare Payload]

    W --> X[POST /upload fileBlob + selectedPages]
    X --> Y[Backend: Validate + Store]

    Y --> Z{Success?}
    Z -->|No| AA[Show Error Toast]
    Z -->|Yes| AB[Receive fileId + batchId]

    AB --> AC[Next.js: router.push /file/fileId]
    AC --> AD[Prefetch File Data]

    style A fill:#2563eb,stroke:#1e40af,stroke-width:2px,color:#fff
    style D fill:#06b6d4,stroke:#0891b2,stroke-width:2px,color:#fff
    style E fill:#06b6d4,stroke:#0891b2,stroke-width:2px,color:#fff
    style F fill:#06b6d4,stroke:#0891b2,stroke-width:2px,color:#fff
    style J fill:#8b5cf6,stroke:#7c3aed,stroke-width:2px,color:#fff
    style K fill:#2563eb,stroke:#1e40af,stroke-width:2px,color:#fff
    style X fill:#dc2626,stroke:#b91c1c,stroke-width:2px,color:#fff
    style Y fill:#10b981,stroke:#059669,stroke-width:2px,color:#fff
    style AC fill:#2563eb,stroke:#1e40af,stroke-width:2px,color:#fff
    style AD fill:#16a34a,stroke:#15803d,stroke-width:2px,color:#fff
```

## Frontend Implementation Pattern

### File Parsing Hook

```tsx
// hooks/useFileParsing.ts
import { useMemo, useState } from 'react'
import * as pdfjsLib from 'pdfjs-dist'
import { parseDocx } from '@/lib/docx-parser'
import { parseOdf } from '@/lib/odf-parser'

export function useFileParsing() {
  const [thumbnails, setThumbnails] = useState<string[]>([])
  const [pageCount, setPageCount] = useState(0)
  const [loading, setLoading] = useState(false)

  const parseFile = async (file: File) => {
    setLoading(true)

    if (file.type === 'application/pdf') {
      const pdf = await pdfjsLib.getDocument(URL.createObjectURL(file)).promise
      setPageCount(pdf.numPages)

      const thumbs = await Promise.all(
        Array.from({ length: pdf.numPages }, async (_, i) => {
          const page = await pdf.getPage(i + 1)
          const viewport = page.getViewport({ scale: 0.5 })
          const canvas = document.createElement('canvas')
          canvas.width = viewport.width
          canvas.height = viewport.height
          await page.render({ canvasContext: canvas.getContext('2d')!, viewport }).promise
          return canvas.toDataURL()
        })
      )
      setThumbnails(thumbs)
    }
    // Similar for DOCX, ODF, images...

    setLoading(false)
  }

  return { parseFile, thumbnails, pageCount, loading }
}
```

### Page Selection Component

```tsx
// components/PageSelector.tsx
'use client'

import { useState } from 'react'
import { useFileParsing } from '@/hooks/useFileParsing'

type SelectionMode = 'page' | 'range'

export function PageSelector({ file }: { file: File }) {
  const { thumbnails, pageCount } = useFileParsing()
  const [mode, setMode] = useState<SelectionMode>('page')
  const [selectedPages, setSelectedPages] = useState<number[]>([])
  const [range, setRange] = useState({ start: 1, end: pageCount })

  const handleSubmit = async () => {
    const pages = mode === 'page' ? selectedPages : Array.from(
      { length: range.end - range.start + 1 },
      (_, i) => range.start + i
    )

    const formData = new FormData()
    formData.append('file', file)
    formData.append('pages', JSON.stringify(pages))

    const response = await fetch('/api/upload', {
      method: 'POST',
      body: formData,
    })

    const data = await response.json()
    router.push('/file/' + data.fileId)
  }

  // Render mode toggle, thumbnail grid for page selection,
  // or range inputs for range selection
  // See full implementation in repository

  return <PageSelectorUI />
}
```

## Backend API Contract

### POST /upload

**Request**:
```http
POST /api/upload
Content-Type: multipart/form-data

file: (binary data)
pages: [1, 3, 5, 7]
userId: "user_123"
```

**Response**:
```json
{
  "success": true,
  "fileId": "file_abc123",
  "batchId": "batch_xyz789",
  "message": "File uploaded successfully. Processing pages in background."
}
```

**Backend Flow**:
```mermaid
graph TD
    A[Receive File + Pages] --> B[Validate File Type + Size]
    B --> C[Generate fileId]
    C --> D[Upload to Azure Blob Storage]
    D --> E[Create MongoDB Document]

    E --> F[Queue Celery Task]
    F --> G[Process Selected Pages]

    G --> H[For Each Page]
    H --> I[Generate Page Image]
    I --> J[Store in Blob Storage]
    J --> K[Save Page URL to MongoDB]

    K --> L[Pusher: Emit page-ready Event]
    L --> M{More Pages?}
    M -->|Yes| H
    M -->|No| N[Complete Batch]

    N --> O[Pusher: Emit batch-complete Event]
    O --> P[Return Response]

    style A fill:#2563eb,stroke:#1e40af,stroke-width:2px,color:#fff
    style D fill:#06b6d4,stroke:#0891b2,stroke-width:2px,color:#fff
    style E fill:#10b981,stroke:#059669,stroke-width:2px,color:#fff
    style F fill:#dc2626,stroke:#b91c1c,stroke-width:2px,color:#fff
    style G fill:#8b5cf6,stroke:#7c3aed,stroke-width:2px,color:#fff
    style L fill:#f59e0b,stroke:#d97706,stroke-width:2px,color:#fff
    style O fill:#f59e0b,stroke:#d97706,stroke-width:2px,color:#fff
    style P fill:#16a34a,stroke:#15803d,stroke-width:2px,color:#fff
```

## UX Optimizations

### 1. Progressive Thumbnail Loading
- Load thumbnails in chunks (4 at a time)
- Show skeleton loaders during generation
- Cache thumbnails in memory for re-selection

### 2. Smart Validation
- Disable submit if no pages selected
- Show warning for large selections (&gt;50 pages)
- Prevent duplicate page selections

### 3. Optimistic UI
- Show upload progress bar immediately
- Disable form during upload
- Show success animation before navigation

### 4. Error Handling
- File size validation (max 100MB)
- Supported file types: PDF, DOCX, ODT, images
- Network error retry with exponential backoff

## Performance Metrics

| Operation | Target Time | Notes |
|-----------|-------------|-------|
| PDF parsing (10 pages) | &lt;500ms | Using Web Workers |
| Thumbnail generation | &lt;100ms/page | Canvas rendering optimized |
| Page selection validation | &lt;50ms | Lodash memoization |
| Upload API call | &lt;2s | Streaming upload with progress |
| Navigation to file page | &lt;200ms | Next.js instant navigation |

## Related Flows

- **[File Page Flow →](/v3-iteration/file-page-flow)** - What happens after upload
- **[State Management →](/v3-iteration/state-management)** - How file data is stored
- **[API Architecture →](/v3-iteration/api-architecture)** - Backend implementation
